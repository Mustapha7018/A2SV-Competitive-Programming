===== APPROACH 1 (CYCLIC SORT) =====
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:

        N = len(nums)

        for i in range(0, N):
            while nums[i] != i and 0 <= nums[i] < N+1 and nums[nums[i]] != nums[i]:
                nums[nums[i]], nums[i] = nums[i], nums[nums[i]]

        for i in range(N):
            if nums[i] != i:
                return nums[i]
        return N


===== APPROACH 2 (HASHMAP) =====
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        
        hashmap = {}
        for i in nums:
            if i not in hashmap:
                hashmap[i] = 1
            else:
                hashmap[i] += 1

        Keymax = max(hashmap, key = lambda x: hashmap[x])

        return Keymax


===== APPROACH 3 (BISECT) =====
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        
        # O(NLogN)
        nums.sort()
        for num in nums:
            left = bisect_left(nums, num)
            right = bisect_right(nums, num) - 1

            if left != right:
                return num

        
        
